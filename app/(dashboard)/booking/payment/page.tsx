"use client"

import { useState } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import { storage } from "@/lib/storage"
import { getApiBase } from "@/lib/api"
import BookingCompleteModal from "@/components/booking/booking-complete-modal"

export default function PaymentPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const amount = Number.parseFloat(searchParams.get("amount") || "0")
  const bookingId = searchParams.get("bookingId") || ""

  const [paymentMethod, setPaymentMethod] = useState("cash")
  const [isProcessing, setIsProcessing] = useState(false)
  const [completedBooking, setCompletedBooking] = useState<any>(null)
  const [completedClientName, setCompletedClientName] = useState<string | null>(null)
  const [completedAccommodationName, setCompletedAccommodationName] = useState<string | null>(null)

  const handleSimulatePayment = async () => {
    setIsProcessing(true)

    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 2000))

    const tempBooking = JSON.parse(sessionStorage.getItem("tempBooking") || "{}")

    const booking = {
      ...tempBooking,
      id: bookingId || tempBooking.id,
      status: "confirmed" as const,
      paymentStatus: "paid" as const,
      transactionId: `TXN${Date.now()}`,
    }

    const API_BASE = getApiBase()

    // Try to create booking on server first when API is configured
    if (typeof window !== 'undefined' && API_BASE) {
      // quick ping to backend to make sure it's reachable and DB connection ok
      try {
        const ping = await fetch(`${API_BASE}/test_db_conn`)
        if (!ping.ok) {
          alert('Booking failed: server API unreachable (ping returned ' + ping.status + '). Please ensure Apache/MySQL are running and backend is reachable.')
          setIsProcessing(false)
          return
        }
        try {
          const pj = await ping.json()
          if (!pj || pj.connected !== true) {
            alert('Booking failed: server DB connection is not ready. Check backend DB settings and XAMPP services.')
            setIsProcessing(false)
            return
          }
        } catch (e) {
          // non-json response; continue and let subsequent calls fail with clearer errors
        }
      } catch (e) {
        alert('Booking failed: server API not reachable. Please start the backend (Apache/MySQL) and verify NEXT_PUBLIC_API_URL.')
        setIsProcessing(false)
        return
      }
      try {
        // Ensure the customer exists on server. Search by email/phone/name first; if not found, create.
        let customerIdToUse = booking.clientId
        const clientObj = storage.getClients().find((c: any) => c.id === booking.clientId)
        if (clientObj) {
          try {
            // Prefer searching by email, then phone, then name
            let searchTerm = ''
            if (clientObj.email) searchTerm = clientObj.email
            else if (clientObj.phoneNumber) searchTerm = clientObj.phoneNumber
            else searchTerm = `${clientObj.firstName} ${clientObj.lastName}`

            if (searchTerm && searchTerm.length >= 2) {
              try {
                const sresp = await fetch(`${API_BASE}/customers?action=search&term=${encodeURIComponent(searchTerm)}`)
                if (sresp.ok) {
                  const sjson = await sresp.json()
                  if (sjson && Array.isArray(sjson.data) && sjson.data.length > 0) {
                    // Try to find best match (email or phone)
                    const match = sjson.data.find((c: any) =>
                      (clientObj.email && c.email === clientObj.email) ||
                      (clientObj.phoneNumber && c.phone === clientObj.phoneNumber) ||
                      (c.first_name === clientObj.firstName && c.last_name === clientObj.lastName)
                    )
                    if (match && match.id) {
                      customerIdToUse = String(match.id)
                    }
                  }
                }
              } catch (e) {
                // ignore search failures and fall back to create
              }
            }

            // If still not matched (or search not available), create customer on server
            if (!customerIdToUse || String(customerIdToUse).length > 10) {
              // numeric local IDs generated by Date.now() can be long - treat them as local-only
              const createResp = await fetch(`${API_BASE}/customers?action=create`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  first_name: clientObj.firstName,
                  last_name: clientObj.lastName,
                  email: clientObj.email || '',
                  phone: clientObj.phoneNumber || '',
                  address: clientObj.address || '',
                }),
              })
              if (createResp.ok) {
                const cjson = await createResp.json()
                if (cjson && cjson.id) {
                  customerIdToUse = String(cjson.id)
                  // update local client id to server id for consistency
                  try {
                    const clients = storage.getClients()
                    const idx = clients.findIndex((c: any) => c.id === clientObj.id)
                    if (idx !== -1) {
                      clients[idx].id = customerIdToUse
                      localStorage.setItem('pos_clients', JSON.stringify(clients))
                    }
                  } catch {}
                }
              }
            }
          } catch (e) {
            // ignore and continue — will be handled later
          }
        }

        const payload = {
          customer_id: customerIdToUse,
          accommodation_id: booking.accommodationId,
          accommodation_name: (() => {
            const acc = storage.getAccommodations().find((a) => a.id === booking.accommodationId)
            return acc ? acc.name : undefined
          })(),
          check_in: booking.dateFrom,
          check_out: booking.dateTo,
          guests: 1,
          total_price: booking.totalAmount,
        }

        const resp = await fetch(`${API_BASE}/bookings?action=create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        })

        if (resp.ok) {
          const json = await resp.json()
          const serverId = json && json.id ? String(json.id) : booking.id
          const serverBooking = { ...booking, id: serverId }
          // ensure booking references the server customer id
          serverBooking.clientId = customerIdToUse

          sessionStorage.removeItem("tempBooking")
          
          // Fetch updated bookings list from server and sync to localStorage
          try {
            const listResp = await fetch(`${API_BASE}/bookings?action=list`)
            if (listResp.ok) {
              const listData = await listResp.json()
              // Handle both array and object with data property
              const serverBookings = Array.isArray(listData) ? listData : (listData?.data || [])
              
              if (serverBookings.length > 0) {
                // Convert server bookings to client format and store
                const clientBookings = serverBookings.map((b: any) => ({
                  id: String(b.id),
                  clientId: String(b.customer_id),
                  accommodationId: String(b.accommodation_id),
                  dateFrom: b.check_in,
                  dateTo: b.check_out,
                  status: b.status || 'confirmed',
                  totalAmount: parseFloat(b.total_price) || 0,
                  createdAt: b.created_at || new Date().toISOString(),
                  paymentStatus: 'paid',
                }))
                localStorage.setItem('pos_bookings', JSON.stringify(clientBookings))
              }
            }
          } catch (e) {
            // non-fatal: continue even if list fetch fails
          }
          
          setIsProcessing(false)
          setCompletedBooking(serverBooking)
          // determine client name for modal (prefer clientObj if available)
          const clientObj = storage.getClients().find((c: any) => c.id === booking.clientId) || null
          if (clientObj) setCompletedClientName(`${clientObj.firstName} ${clientObj.lastName}`)
          else setCompletedClientName(null)
          const accommodation = storage.getAccommodations().find((a) => a.id === serverBooking.accommodationId)
          setCompletedAccommodationName(accommodation?.name || null)
          return
        } else {
          // Try to parse error body
          let errText = 'Failed to create booking on server'
          try {
            const errJson = await resp.json()
            if (errJson && errJson.error) errText = String(errJson.error)
          } catch {}
          alert(errText)
          setIsProcessing(false)
          return
        }
      } catch (e) {
        // fall back to local-only if server call fails
      }
    }

    // If API not configured or unavailable, prevent booking — require server persistence
    alert('Booking failed: server API not configured or unreachable. Booking must be created on the server.')
    setIsProcessing(false)
    return
  }

  const handleCloseModal = () => {
    setCompletedBooking(null)
    router.push("/dashboard")
  }

  if (completedBooking) {
    const checkIn = new Date(completedBooking.dateFrom)
    const checkOut = new Date(completedBooking.dateTo)
    const nights = Math.floor((checkOut.getTime() - checkIn.getTime()) / (1000 * 60 * 60 * 24))

    return (
      <BookingCompleteModal
        booking={completedBooking}
        clientName={completedClientName || 'Guest'}
        accommodationName={completedAccommodationName || 'Accommodation'}
        checkIn={completedBooking.dateFrom}
        checkOut={completedBooking.dateTo}
        nights={nights}
        onClose={handleCloseModal}
      />
    )
  }

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
      <div className="w-full max-w-md bg-white border border-gray-200 rounded-lg p-8 shadow-lg">
        <h1 className="text-3xl font-bold text-blue-900 mb-6 text-center">Confirm Payment</h1>

        <div className="bg-blue-50 p-6 rounded mb-6 text-center border border-blue-200">
          <p className="text-sm text-gray-600 mb-2 font-medium">Total Amount Due</p>
          <p className="text-4xl font-bold text-yellow-500">₱{amount.toLocaleString()}</p>
        </div>

        <div className="space-y-4 mb-6">
          <label className="block">
            <span className="block text-sm font-bold text-gray-700 mb-3">Payment Method</span>
            <select
              value={paymentMethod}
              onChange={(e) => setPaymentMethod(e.target.value)}
              className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            >
              <option value="cash">Cash Payment</option>
              <option value="gcash">GCash</option>
              <option value="credit">Credit Card</option>
              <option value="bank">Bank Transfer</option>
            </select>
          </label>
        </div>

        <button
          onClick={handleSimulatePayment}
          disabled={isProcessing}
          className="w-full py-3 bg-yellow-400 text-blue-900 font-bold rounded-lg hover:bg-yellow-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        >
          {isProcessing ? "Processing Payment..." : "Confirm & Process Payment"}
        </button>

        <div className="mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200 text-xs text-gray-700">
          <p className="font-bold mb-1 text-blue-900">Payment Confirmation</p>
          <p>Payment will be processed securely. A receipt will be generated upon completion.</p>
        </div>
      </div>
    </div>
  )
}
